# 自定义学习率策略使用说明

## 概述

本文档介绍如何使用自定义学习率策略功能，通过控制对角矩阵D来实现不同的收敛因子c值。这个功能允许研究人员探索学习率分布对分布式优化算法收敛性能的影响。

## 理论背景

收敛因子c的计算公式为：
```
c = n * π_A^T * D * π_B
```

其中：
- `n` 是节点数量
- `π_A` 是矩阵A的左Perron向量
- `π_B` 是矩阵B的右Perron向量
- `D` 是对角矩阵，其对角线元素表示归一化的学习率

通过调整D的对角线元素，可以控制c值的大小，从而研究不同c值对算法收敛速度的影响。

## 新增功能

### 1. D矩阵生成工具 (`utils/d_matrix_utils.py`)

提供了以下主要函数：

- `generate_d_matrices_with_increasing_c()`: 生成产生递增c值的D矩阵
- `generate_specific_d_matrices()`: 生成特定策略（uniform、pi_a_inverse、pi_b_inverse等）的D矩阵
- `compute_c_from_d_diagonal()`: 根据D的对角线计算c值

### 2. 自定义策略支持

在 `experiment_utils.py` 中添加了 `"custom"` 策略选项，允许直接传入D矩阵的对角线值。

### 3. 独立实验脚本 (`run_custom_strategy_experiments.py`)

专门用于运行自定义策略实验的脚本，支持：
- 自动生成多个不同c值的D矩阵
- 批量运行实验
- 结果可视化（如果安装了matplotlib）

## 使用方法

### 方法1：使用独立实验脚本

#### 基本用法
```bash
python scripts_pushpull_differ_lr/run_custom_strategy_experiments.py \
    --topology neighbor \
    --n 16 \
    --matrix_seed 42 \
    --lr_basic 0.007 \
    --num_c_values 5 \
    --dataset_name MNIST \
    --batch_size 128 \
    --num_epochs 100 \
    --alpha 1000 \
    --use_hetero \
    --device cuda:0
```

#### 测试特定策略
```bash
python scripts_pushpull_differ_lr/run_custom_strategy_experiments.py \
    --topology ring \
    --n 16 \
    --matrix_seed 42 \
    --lr_basic 0.007 \
    --use_specific_strategies \
    --dataset_name MNIST \
    --batch_size 128 \
    --num_epochs 50 \
    --alpha 1000 \
    --use_hetero
```

#### 指定c值范围
```bash
python scripts_pushpull_differ_lr/run_custom_strategy_experiments.py \
    --topology neighbor \
    --n 16 \
    --matrix_seed 42 \
    --lr_basic 0.007 \
    --num_c_values 10 \
    --c_min 0.5 \
    --c_max 2.0 \
    --dataset_name MNIST \
    --batch_size 128 \
    --num_epochs 100 \
    --alpha 1000 \
    --use_hetero
```

### 方法2：在Python脚本中使用

```python
import numpy as np
from scripts_pushpull_differ_lr.experiment_utils import generate_topology_matrices
from utils.d_matrix_utils import generate_d_matrices_with_increasing_c
from scripts_pushpull_differ_lr.run_experiment import run_distributed_optimization_experiment

# 生成拓扑
A, B = generate_topology_matrices("neighbor", n=16, matrix_seed=42, k=3)

# 生成5个递增c值的D矩阵
d_results = generate_d_matrices_with_increasing_c(A, B, num_c_values=5)

# 对每个D矩阵运行实验
for d_diagonal, c_value in d_results:
    df = run_distributed_optimization_experiment(
        topology="neighbor",
        n=16,
        matrix_seed=42,
        lr_basic=0.007,
        strategy="custom",
        d_diagonal=d_diagonal,  # 传入自定义D对角线
        dataset_name="MNIST",
        batch_size=128,
        num_epochs=100,
        alpha=1000,
        use_hetero=True,
        remark=f"c_{c_value:.4f}",
        device="cuda:0"
    )
```

### 方法3：直接指定D矩阵

```python
# 创建自定义D对角线（必须和为n）
n = 16
d_diagonal = np.random.rand(n)
d_diagonal = d_diagonal * n / np.sum(d_diagonal)  # 归一化

# 运行实验
df = run_distributed_optimization_experiment(
    topology="ring",
    n=n,
    matrix_seed=42,
    lr_basic=0.007,
    strategy="custom",
    d_diagonal=d_diagonal,
    dataset_name="MNIST",
    batch_size=128,
    num_epochs=100,
    alpha=1000,
    use_hetero=True
)
```

## 输出结果

### 1. 实验目录结构
```
custom_experiments/
└── custom_strategy_20250122_150000_neighbor_16nodes/
    ├── experiment_summary.json              # 实验总结
    ├── c_vs_grad_norm.png                  # c值与梯度范数关系图
    ├── experiment_20250122_150100_neighbor_custom_16nodes/  # 各个c值的子实验
    │   ├── config.yaml
    │   └── *.csv files
    └── ...
```

### 2. 实验总结文件 (`experiment_summary.json`)
包含：
- 所有测试的c值
- 每个c值对应的最终梯度范数
- 实验参数配置

### 3. 可视化结果
如果安装了matplotlib，会自动生成c值与最终梯度范数的关系图。

## 参数说明

### 必需参数
- `--topology`: 网络拓扑类型
- `--n`: 节点数量
- `--matrix_seed`: 拓扑生成种子
- `--lr_basic`: 基础学习率
- `--dataset_name`: 数据集名称
- `--batch_size`: 批次大小
- `--num_epochs`: 训练轮数
- `--alpha`: 异质性参数

### 可选参数
- `--num_c_values`: 要测试的不同c值数量（默认5）
- `--c_min`: 最小c值（不指定则自动确定）
- `--c_max`: 最大c值（不指定则自动确定）
- `--use_specific_strategies`: 测试特定策略而非c值范围
- `--repetitions`: 每个c值的重复次数（默认1）
- `--device`: GPU设备（默认cuda:0）
- `--output_dir`: 输出目录（默认./custom_experiments）

## 示例用例

### 1. 研究c值对收敛速度的影响
```bash
# 生成10个从小到大的c值并测试
python run_custom_strategy_experiments.py \
    --topology neighbor --n 16 --matrix_seed 42 \
    --lr_basic 0.007 --num_c_values 10 \
    --dataset_name MNIST --batch_size 128 \
    --num_epochs 200 --alpha 1000 --use_hetero
```

### 2. 比较不同策略的c值
```bash
# 测试uniform、pi_a_inverse、pi_b_inverse等策略
python run_custom_strategy_experiments.py \
    --topology ring --n 16 --matrix_seed 42 \
    --lr_basic 0.007 --use_specific_strategies \
    --dataset_name CIFAR10 --batch_size 64 \
    --num_epochs 100 --alpha 1000 --use_hetero
```

### 3. 探索极端c值
```bash
# 测试从很小到很大的c值
python run_custom_strategy_experiments.py \
    --topology grid --n 16 --matrix_seed 42 \
    --lr_basic 0.007 --num_c_values 20 \
    --c_min 0.1 --c_max 5.0 \
    --dataset_name MNIST --batch_size 128 \
    --num_epochs 150 --alpha 1000 --use_hetero
```

## 注意事项

1. **D矩阵约束**：D的对角线元素必须为正数，且和等于节点数n
2. **c值范围**：自动确定的c值范围基于随机采样，可能不包含理论上的最小/最大值
3. **内存使用**：运行多个实验时注意GPU内存使用
4. **收敛性**：某些极端的D矩阵可能导致算法不收敛

## 故障排除

1. **"d_diagonal must be provided when strategy='custom'"错误**
   - 确保在使用custom策略时提供了d_diagonal参数

2. **c值计算不准确**
   - 检查D矩阵是否正确归一化（和为n）
   - 验证A和B矩阵的性质（行随机/列随机）

3. **生成的c值范围太小**
   - 增加num_samples参数以获得更好的c值范围估计
   - 手动指定c_min和c_max

## 扩展开发

如需自定义D矩阵生成逻辑，可以：

1. 在 `utils/d_matrix_utils.py` 中添加新的生成函数
2. 修改 `run_custom_strategy_experiments.py` 以使用新的生成逻辑
3. 保持D矩阵的约束条件（正数、和为n）